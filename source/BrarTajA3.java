/* autogenerated by Processing revision 1286 on 2023-02-06 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class BrarTajA3 extends PApplet {

Grid g1 = new Grid();    // first grid used to draw tiles
Grid g2 = new Grid();    // second grid used to draw tiles and create illusion of a continuous grid

final float L = -1;      // left coordinate of the frustum
final float R = 1;       // right coordinate of the frustum
final float B = -1;      // bottom cooridante of the frustum
final float T = 1;       // top coordinate of the frustum
final float N = 1;       // distance to near plane
final float F = 10;      // distance to far plane

final float PLAYER_HEIGHT = -F+1.35f;  // z coordinate of the player
final float PLAYER_SIZE = 0.15f;       // size of the player
final float GRID_SIZE = 6;            // size of a grid of tiles
final float SPEED = -0.01f;            // speed at which a grid moves
float positionG1 = 0;                 // starting position of the first grid (center of screen)
float positionG2 = GRID_SIZE;         // starting position of the second grid (above first grid)
boolean gameOver = false;             // boolean to track if game is over or not

// Set up images for textures
final String PLAYER_FILE_NAME = "player.png";
final String ENEMY_FILE1_NAME = "enemy1.png";
final String ENEMY_FILE2_NAME = "enemy2.png";
final String ENEMY_FILE3_NAME = "enemy3.png";
final String PLAYER_BULLET_FILE_NAME = "playerBullet.png";
final String ENEMY_BULLET_FILE_NAME = "enemyBullet.png";
final String SIDE_TILE_NAME = "sideTile.png";
final String TOP_TILE_NAME1 = "topTile1.png";
final String TOP_TILE_NAME2 = "topTile2.png";
PImage PLAYER_IMAGE;
PImage ENEMY_IMAGE1;
PImage ENEMY_IMAGE2;
PImage ENEMY_IMAGE3;
PImage PLAYER_BULLET_IMAGE;
PImage ENEMY_BULLET_IMAGE;
PImage SIDE_TILE_IMAGE;
PImage TOP_TILE_IMAGE1;
PImage TOP_TILE_IMAGE2;

 public void setup() {
  /* size commented out by preprocessor */; // change the dimensions if desired
  colorMode(RGB, 1.0f);
  textureMode(NORMAL); // use normalized 0..1 texture coords
  textureWrap(REPEAT);

  setupPOGL();
  setupProjections();
  resetMatrix(); // do this here and not in draw() so that you don't reset the camera

  // do any additional setup here
  // Initialize grids
  g1.initializeGrid();
  g2.initializeGrid();

  // Setup enemies and their keyframes
  setupKeyframes();
  setupEnemies();

  // Set up textures from images
  setupImages();
}// setup

 public void draw() {
  // Draw grids at their positions
  drawGridAtPosition(g1, positionG1);
  drawGridAtPosition(g2, positionG2);

  // Run enemies
  runEnemies();

  // Play game while not done
  if (!gameOver) {
    // Move grids across screen
    moveGrids();

    // Draw player
    drawPlayer();

    // Move player
    updatePlayer();

    // Draw player bullets
    playerBullets.run();

    // Run enemies
    runEnemies();

    // Check for collisons and act accordingly
    if (doCollision)
      checkCollisions();
  }// if

  // Run explosions
  runExplosions();
}// draw
final float MAX_DIST = 4;                          // maximum distance that can be travelled by a bullet
final float DELTA_ANGLE = PI/20;                   // change in bullet angle every frame
final float[] BULLET_COLOUR = {0, 0, 1};           // colour of the bullet
final float BULLET_HEIGHT = PLAYER_HEIGHT - 0.14f;  // z cooridnate of the bullets

/*
  This class implements bullets for a given enitity (player/enemy).
 */
class Bullets {
  ArrayList<Bullet> bullets;    // list of all bullets

  /*
   Create Bullets object
   */
  Bullets() {
    // Initialize ArrayList
    bullets = new ArrayList<Bullet>();
  }// Bullets - constructor

  /*
    This method runs this set of bullets.
   */
   public void run() {
    // Remove dead bullets
    removeDeadBullets();

    // Run all bullets in ArrayList
    for (int i=0; i<bullets.size(); i++)
      bullets.get(i).run();
  }// run

  /*
    This method removes all dead bullets from this set of objects.
   */
   public void removeDeadBullets() {
    // Loop through all bullets
    for (int i=0; i<bullets.size(); i++) {
      // Remove bullet if its dead
      if (!bullets.get(i).alive)
        bullets.remove(i);
    }// for
  }// removeDeadBullets

  /*
  This method adds a bullet given its coords., direction, speed, texture, and size
   */
   public void add(float xStart, float yStart, PVector towards, float speed, Textures t, float size) {
    // Create new bullet and insert into ArrayList
    Bullet b = new Bullet(xStart, yStart, towards, speed, t, size);
    bullets.add(b);
  }// addBullet
}// end class Bullets

/*
  This class implements a single bullet.
 */
class Bullet {
  float xPos;
  float yPos;
  float distTravelled;
  float speed;
  float bulletSize;
  float angle;
  boolean alive;
  PVector direction;
  Textures texture;

  /*
   This method creates a bullet given its coords., direction, speed, texture, and size.
   */
  Bullet(float xStart, float yStart, PVector towards, float bulletSpeed, Textures t, float size) {
    // Instantiate object
    xPos = xStart;
    yPos = yStart;
    alive = true;
    direction = towards;
    speed = bulletSpeed;
    texture = t;
    bulletSize = size;
    distTravelled = 0;
    angle = 0;
  }// Bullet - constructor

  /*
    This method runs this bullet.
   */
   public void run() {
    // Draw bullet
    drawBullet();

    // Move bullet if game running
    if (!gameOver)
      moveBullet();
  }// run

  /*
    This method moves the bullet.
   */
   public void moveBullet() {
    // Get angle with horizontal
    float angle = direction.heading();

    // Move bullet in dir.
    xPos += cos(angle)*speed;
    yPos += sin(angle)*speed;
    distTravelled += speed;

    // Check if beyond death point
    if (distTravelled > MAX_DIST)
      alive = false;

    // Update the angle
    updateAngle();
  }// moveBullet

  /*
    This method updates the angle of the bullet.
   */
   public void updateAngle() {
    // Get new angle based on delta
    angle = (angle + DELTA_ANGLE) % TWO_PI;
  }// updateAngle

  /*
    This method draws the bullet at its current location.
   */
   public void drawBullet() {
    pushMatrix();

    // Color bullet
    fill(255, 0, 0);

    // Draw bullet at correct size and location
    translate(xPos, yPos, BULLET_HEIGHT);
    rotate(angle);
    scale(bulletSize);
    if (doTextures)
      drawSquare(null, texture);
    else
      drawSquare(BULLET_COLOUR, null);

    popMatrix();
  }// drawBullet
}// end class Bullet
ArrayList<Enemy> enemies = new ArrayList<Enemy>();    // list of all enemies
int numEnemies = 0;                                   // number of enemies that exist
int numSpawned = 0;                                   // total number of enemies spawned
float currentShootSpacing = 60;                       // current frames before an enemy can shoot again
float currentBulletSpeed = 0.005f;                     // current speed of enemy bullets
final int MAX_ENEMIES = 5;                            // maximum number of enemies allowed
final int MAX_BULLETS = 3;                            // maximum number of bullets an enemy can have in existance
final int ENEMY_MAX_FRAMES = 120;                     // maximum number of frames the enemy can have a given texture
final float DELTA_SHOOT_SPACING = 1/3f;               // change in frames before an enemy can shoot again
final float DELTA_BULLET_SPEED = 0.0005f;              // change in speed of enemy bullets
final float ENEMY_SIZE = 0.15f;                        // size of enemy in world
final float ENEMY_SHOOT_RANGE = 1;                    // range within which enemy "sees" player
final float ENEMY_BULLET_SIZE = PLAYER_SIZE/4;        // size of enemy bullets
final float ENEMY_HEIGHT = PLAYER_HEIGHT - 0.15f;      // z coordiante of enemies
final float[] ENEMY_COLOUR = {0, 0, 0};               // colour of enemies

/*
  This method adds the max number of enemies to start.
 */
 public void setupEnemies() {
  // Add max number of enemies
  for (int i=0; i<MAX_ENEMIES; i++) {
    addEnemy();
  }// for
}// setupEnemies

/*
  This method adds an enemy to the list.
 */
 public void addEnemy() {
  enemies.add(new Enemy());
  numEnemies++;
}// addEnemy

/*
  This method returns the next texture for the enemy.
 */
 public Textures nextEnemyTexture(Textures currTexture) {
  Textures t = null;

  if (currTexture == Textures.enemy1)
    t = Textures.enemy2;
  else if (currTexture == Textures.enemy2)
    t = Textures.enemy3;
  else if (currTexture == Textures.enemy3)
    t = Textures.enemy1;

  return t;
}// nextEnemyTexture

/*
  This method runs all enemys in the list.
 */
 public void runEnemies() {
  Enemy e;    // current enemy in list

  // Loop through all enemies in list
  for (int i=0; i<enemies.size(); i++) {
    // Get enemy and run it
    e = enemies.get(i);
    e.run();

    // Check if dead and no bullets
    if (!e.alive && e.enemyBullets.bullets.size() == 0) {
      enemies.remove(e);
      numEnemies--;
    }// if
  }// for

  // Add a new enemy if one died
  if (numEnemies < MAX_ENEMIES) {
    increaseDifficulty();
    addEnemy();
  }// if
}// runEnemies

/*
  This method increases the game difficulty by making the
 enemy shoot more frequently with bullets that travel faster.
 */
 public void increaseDifficulty() {
  // Decrease shoot spacing
  if (currentShootSpacing > DELTA_SHOOT_SPACING)
    currentShootSpacing -= DELTA_SHOOT_SPACING;

  // Increase bullet speed
  currentBulletSpeed += DELTA_BULLET_SPEED;
}// increaseDifficulty

/*
  This class implements an enemy for the game.
 */
class Enemy {
  int enemyNumber;       // enemy ID
  int framesSinceShot;   // frames since the enemy last shot
  int frameAge;          // number of frames passed since last shot
  float xPos;            // x coordinate of the enemy
  float yPos;            // y coordiante of the enemy
  float shootSpacing;    // number of frames that must pass before shooting
  float bulletSpeed;     // speed of the bullets shot by enemy
  Bullets enemyBullets;  // bullets shot by this enemy
  Boolean alive;         // Boolean to track if enemy is alive
  Textures texture;      // Current texture of the enemy

  int counter;              // counter used for keyframes
  int startFrame, endFrame; // startFrame and endFrame indices of current keyframe

  /*
    This method creates a new enemy.
   */
  Enemy() {
    // Get enemy ID
    enemyNumber = numSpawned++;

    // Initialize varaibles used for key frames
    counter = 0;
    startFrame = enemyNumber%NUM_KEY_FRAMES;
    endFrame = (startFrame+1)%NUM_KEY_FRAMES;

    // Initialize enemy
    xPos = keyFrames[startFrame][X];
    yPos = keyFrames[startFrame][Y];
    enemyBullets = new Bullets();
    shootSpacing = currentShootSpacing;
    bulletSpeed = currentBulletSpeed;
    framesSinceShot = 0;
    frameAge = 0;
    texture = Textures.enemy1;
    alive = true;
  }// Enemy - constructor

  /*
    This method runs the enemy.
   */
   public void run() {
    if (alive == true) {
      drawEnemy();

      if (!gameOver) {
        moveEnemy();
        shootAtPlayer();
        updateCounter();
        frameAge++;

        if (frameAge%ENEMY_MAX_FRAMES == 0) {
          frameAge = 0;

          texture = nextEnemyTexture(texture);
        }// if
      }// if
    }// if

    enemyBullets.run();
  }// run

  /*
  This method moves the enemy based on keyframes.
   */
   public void moveEnemy() {
    // Get parameter for lerping
    float t = (float)counter/numSteps[startFrame];
    float tPrime = 0.5f*(1-cos(PI*t));

    xPos = lerp(keyFrames[startFrame][0], keyFrames[endFrame][0], tPrime);
    yPos = lerp(keyFrames[startFrame][1], keyFrames[endFrame][1], tPrime);
  }// moveEnemy

  /*
    This method draw the enemy at its current location.
   */
   public void drawEnemy() {
    // Draw enemy
    pushMatrix();

    // Modify square
    translate(xPos, yPos, ENEMY_HEIGHT);
    scale(ENEMY_SIZE, ENEMY_SIZE, 1);

    // Draw square with texture or not
    if (doTextures)
      drawSquare(null, texture);
    else
      drawSquare(ENEMY_COLOUR, null);

    popMatrix();
  }// drawPlayer

  /*
    This method make the enemy shoot at the player if it is within range.
   */
   public void shootAtPlayer() {
    PVector playerLocation = new PVector(xPlayer, yPlayer);
    PVector enemyLocation = new PVector(xPos, yPos);
    PVector direction;

    // Check if enemy within range of player and can shoot more
    if (PVector.dist(playerLocation, enemyLocation) < ENEMY_SHOOT_RANGE
      && enemyBullets.bullets.size() < MAX_BULLETS) {

      // Check if it has been enough time between shots
      if (framesSinceShot > shootSpacing) {
        // Get direction of bullets
        direction = playerLocation;
        direction.sub(new PVector(xPos, yPos));

        // Shoot bullet in that direction
        enemyBullets.add(xPos, yPos, direction, bulletSpeed, Textures.enemyBullet, ENEMY_BULLET_SIZE);

        // Reset counter since bullet shot
        framesSinceShot = 0;
      } else {
        // Bullet not shot - increment counter
        framesSinceShot++;
      }// if-else
    }// if
  }// shootAtPlayer

  /*
    This method updates the counter used to lerp between keyframes.
   */
  private void updateCounter() {
    // Update counter
    counter++;

    // Check if the keyframe needs to be updated
    if (counter >= numSteps[startFrame]) {
      // Move to next frame
      startFrame = (startFrame+1) % NUM_KEY_FRAMES;
      endFrame = (endFrame+1) % NUM_KEY_FRAMES;

      // Reset counter
      counter = 0;
    }// if
  }// updateCounter
}// class end Enemy
final float PARTICLE_SIZE = 0.01f;          // size of the particle
final float PARTICLE_SPEED = 0.05f;         // speed at which particle moves
final int NUM_PARTICLES = 100;             // number of particles per explosion
final int MAX_LIFE = 30;                   // max number of frames the explosion lasts for
final float[] PARTICLE_COLOR = {1, 0, 0};  // colour of particles in explosion

ArrayList<Explosion> explosions = new ArrayList();    // list of all explosion

/*
  This class implements an explosion.
 */
class Explosion {
  float xPos;      // x position of the explosion
  float yPos;      // y position of the explosion
  Boolean alive;   // boolean to track if explosion is alive
  int age;         // age of explosion in frames
  ArrayList<Particle> particles;  // list of all particles in explosion

  /*
    This method creates a new instance at the given coordinates.
   */
  Explosion(float x, float y) {
    // Instantiate explosion
    xPos = x;
    yPos = y;
    alive = true;
    age = 0;
    particles = new ArrayList();

    // Add particles to explosion
    addParticles();
  }// Explosion - constructor

  /*
    This method adds the max number of particles to the explosion.
   */
   public void addParticles() {
    // Add max number of particles
    for (int i=0; i<NUM_PARTICLES; i++)
      particles.add(new Particle(xPos, yPos));
  }// addParticles

  /*
    This method runs the explosion by running each particle.
   */
   public void run() {
    // Loop through all particles and run them
    for (int i=0; i<particles.size(); i++)
      particles.get(i).run();

    // Kill explosion if beyond max lifetime
    if (age > MAX_LIFE)
      alive = false;
    else
      age++;
  }// run
}// end class Explosion

/*
  This class implements a particle.
 */
class Particle {
  float xPos;        // x position of the particle
  float yPos;        // y position of the particle
  float zPos;        // z position of the particle
  PVector direction; // direction the particle is travelling in

  /*
    This method creates a particle at a given location.
   */
  Particle (float x, float y) {
    // Instantiate particle
    xPos = x;
    yPos = y;
    zPos = PLAYER_HEIGHT;    // explosion starts at fixes z height

    // Get random direction of travel
    direction = PVector.random3D();
  }// Particle - constructor

  /*
    This method runs the particle.
   */
   public void run() {
    // Move and draw particle
    moveParticle();
    drawParticle();
  }// run

  /*
    This method moves the particle in its direction of travel.
   */
   public void moveParticle() {
    // Move particle in determined direction
    xPos += PARTICLE_SPEED*direction.x;
    yPos += PARTICLE_SPEED*direction.y;
    zPos += PARTICLE_SPEED*direction.z;
  }// moveParticle

  /*
    This method draws the particle at its given location.
   */
   public void drawParticle() {
    pushMatrix();

    // Apply modifications and draw particle
    translate(xPos, yPos, zPos);
    scale(PARTICLE_SIZE, PARTICLE_SIZE, 0);
    drawParticleCube(PARTICLE_COLOR);

    popMatrix();
  }// drawParticle
}// end class Particle
final int RED = 0;        // index of red colour
final int GREEN = 1;      // index of green colour
final int BLUE = 2;       // index of blue colour
final int NUM_COLORS = 3; // number of colours

/*
  This method draws a given grid at the given position.
 */
 public void drawGridAtPosition(Grid gridToDraw, float position) {
  pushMatrix();

  // Move to given position and draw grid
  translate(0, position, 0);
  gridToDraw.drawGrid();

  popMatrix();
}// drawGridAtPosition

/*
  This method moves both grids at a set speed.
 */
 public void moveGrids() {
  // Move grids at set speed
  positionG1 = positionG1 + SPEED;
  positionG2 = positionG2 + SPEED;

  // Check if grid 1 went out of view
  if (positionG1 < -GRID_SIZE) {
    // Reset tiles
    g1.initializeGrid();

    // Reset to above grid 2
    positionG1 = positionG2 + GRID_SIZE;
  }// if

  // Check if grid 2 went out of view
  if (positionG2 < -GRID_SIZE) {
    // Reset tiles
    g2.initializeGrid();

    // Reset to above grid 1
    positionG2 = positionG1 + GRID_SIZE;
  }// if
}// moveGrids

/*
  This class implements a grid with tiles.
 */
class Grid {
  final float MIN_HEIGHT = 0.5f;                                 // minimum height of a tile
  final float MAX_HEIGHT = 0.7f;                                 // maximum height of a tile
  final float CUBE_SIZE = 0.1f;                                  // half length of a cube side
  final float START_X = -GRID_SIZE/2 + CUBE_SIZE;               // x coord. of where grid starts
  final float START_Y = -GRID_SIZE/2 + CUBE_SIZE;               // y coord. of where grid starts
  final float END_X = GRID_SIZE/2 + CUBE_SIZE;                  // x coord. of where grid ends
  final float END_Y = GRID_SIZE/2 + CUBE_SIZE;                  // y coord. of where grid ends
  final int NUM_TILES = (int)((END_X-START_X)/(2*CUBE_SIZE));   // number of tiles in a grid row

  float[][] tileHeights = new float[NUM_TILES][NUM_TILES];
  Textures[][] tileTextures = new Textures[NUM_TILES][NUM_TILES];
  float[][][] tileColors = new float[NUM_TILES][NUM_TILES][NUM_COLORS];

  /*
    This method intializes the grid by setting the colours, heights, and the textures.
   */
   public void initializeGrid() {
    setColors();
    setHeights();
    setTextures();
  }// initializeGrid

  /*
    This method sets the color of the tiles in the grid.
   */
   public void setColors() {
    // Loop through each row of tiles
    for (int i=0; i<NUM_TILES; i++) {
      // Loop through tiles in a row
      for (int j=0; j<NUM_TILES; j++) {
        // Get random color and insert into array
        // Loop through each color
        for (int k=0; k<NUM_COLORS; k++) {
          tileColors[i][j][k] = random(256)/256.0f;
        }// for
      }// for
    }// for
  }// setColor

  /*
    This method sets the textures of the tiles in the grid (one of two).
   */
   public void setTextures() {
    // Loop through each row of tiles
    for (int i=0; i<NUM_TILES; i++) {
      // Loop through tiles in a row
      for (int j=0; j<NUM_TILES; j++) {
        // Get random height and insert into array
        tileTextures[i][j] = (random(1) < 0.5f) ? Textures.tile1 : Textures.tile2;
      }// for
    }// for
  }// setTextures

  /*
    This method sets the heights of the tiles in the grid randomly.
   */
   public void setHeights() {
    // Loop through each row of tiles
    for (int i=0; i<NUM_TILES; i++) {
      // Loop through tiles in a row
      for (int j=0; j<NUM_TILES; j++) {
        // Get random height and insert into array
        tileHeights[i][j] = random(MIN_HEIGHT, MAX_HEIGHT);
      }// for
    }// for
  }// setColor

  /*
    This method draws the grid by drawing all tiles.
   */
   public void drawGrid() {
    float x, y, z;    // coords. of a tile

    // Loop through each row of tiles
    for (int i=0; i<NUM_TILES; i++) {
      // Loop through tiles in a row
      for (int j=0; j<NUM_TILES; j++) {
        // Get coords of tile
        x = START_X + j*CUBE_SIZE*2;
        y = START_Y + i*CUBE_SIZE*2;
        z =  -F+tileHeights[i][j]/2;

        // Draw current tile
        pushMatrix();
        translate(x, y, z);
        scale(CUBE_SIZE, CUBE_SIZE, tileHeights[i][j]);
        drawCube(tileColors[i][j], tileTextures[i][j]);
        popMatrix();
      }// for
    }// for
  }// drawTiles
}// end class Grid
final int X = 0;                    // index of x coord.
final int Y = 1;                    // index of y coord.
final int NUM_KEY_FRAMES = 6;       // number of keyframes
final float PIXELS_PER_SEC = 0.1f;   // speed of animation

float[][] keyFrames = new float[NUM_KEY_FRAMES][2];    // coords. of all keyframes
float[] numSteps = new float[NUM_KEY_FRAMES];          // number of steps for all keyframes (for const. speed)

/*
  This method sets up all the keyframe coords and corresponding number of steps.
 */
 public void setupKeyframes() {
  // Set locations for the keyframes
  // First keyframe
  keyFrames[0][X] = 0;
  keyFrames[0][Y] = 0;

  // Second keyframe
  keyFrames[1][X] = -1+ENEMY_SIZE/2;
  keyFrames[1][Y] = 0;

  // Third keyframe
  keyFrames[2][X] = 0;
  keyFrames[2][Y] = 1-ENEMY_SIZE/2;

  // Fourth keyframe
  keyFrames[3][X] = 0.5f;
  keyFrames[3][Y] = 0.5f;

  // Fifth keyframe
  keyFrames[4][X] = 1-ENEMY_SIZE/2;
  keyFrames[4][Y] = 1-ENEMY_SIZE/2;

  // Sixth keyframe
  keyFrames[5][X] = 1-ENEMY_SIZE/2;
  keyFrames[5][Y] = 0;

  // Get steps for all keyframes
  for (int i=0; i<NUM_KEY_FRAMES; i++)
    numSteps[i] = getNumSteps(keyFrames[i], keyFrames[(i+1)%NUM_KEY_FRAMES]);
}// setupKeyFrames

/*
  This method gets the number of steps given the start and end coords.
 */
 public float getNumSteps(float[] start, float[] end) {
  // Get vectors from array
  PVector startVec = new PVector(start[X], start[Y]);
  PVector endVec = new PVector(end[X], end[Y]);

  // Get displacement between start and end
  PVector displacement = endVec.copy();
  displacement.sub(startVec);

  // Get distance between start and end
  float distance = displacement.mag();

  // Calculate and return the number of steps
  return distance*frameRate/PIXELS_PER_SEC;
}// getNumSteps
final char KEY_VIEW = 'r'; // switch between orthographic and perspective views

// player character
final char KEY_LEFT = 'a';
final char KEY_RIGHT = 'd';
final char KEY_UP = 'w';
final char KEY_DOWN = 's';
final char KEY_SHOOT = ' ';

// useful for debugging to turn textures or collisions on/off
final char KEY_TEXTURE = 't';
final char KEY_COLLISION = 'c';

final char KEY_BONUS = 'b';

boolean doBonus = false;
boolean doTextures = false;
boolean doCollision = false;

boolean modeOrtho = true;

 public void keyPressed()
{
  // Act from input if game going
  if (!gameOver) {
    // Proceed based on key pressed
    switch (key) {
    case KEY_VIEW:
      switchViews();
      break;
    case KEY_LEFT:
      moveLeft = true;
      break;
    case KEY_RIGHT:
      moveRight = true;
      break;
    case KEY_UP:
      moveUp = true;
      break;
    case KEY_DOWN:
      moveDown = true;
      break;
    case KEY_SHOOT:
      playerShooting = true;
      break;
    case KEY_COLLISION:
      doCollision = !doCollision;
      break;
    case KEY_TEXTURE:
      doTextures = !doTextures;
      break;
    }// switch
  }// if
}// keyPressed

 public void keyReleased() {
  // Act from input if game going
  if (!gameOver) {
    // Proceed based on key released
    switch (key) {
    case KEY_LEFT:
      moveLeft = false;
      break;
    case KEY_RIGHT:
      moveRight = false;
      break;
    case KEY_UP:
      moveUp = false;
      break;
    case KEY_DOWN:
      moveDown = false;
      break;
    case KEY_SHOOT:
      playerShooting = false;
      break;
    }// switch
  }// if
}// keyReleased

/*
  This method switches between orthographic and perspective view by changing the
  camera location and the setting the appropriate projection matrix.
 */
 public void switchViews() {
  // Switch projection modes
  modeOrtho = !modeOrtho;

  // Proceed based on new mode
  if (modeOrtho) {
    // Change projection matrix and move camera
    setProjection(projectOrtho);
    camera(0, 0, 0, 0, 0, -F, 0, 1, 0);
  } else {
    // Change projection matrix and move camera
    setProjection(projectPerspective);
    camera(0, 0, -7.49f, 0, 0, -F, 0, 1, 0);    // maps nicely
    //camera(0, -1, -7.2, 0, 0, -F, 0, 1, 0);    // has more perspective
  }// if-else

  // Print statement
  println("PROJECTION MODE: " + (modeOrtho ? "ORTHO" : "PERSPECTIVE"));
}// switchViews
final float MOVE_SPEED = 0.02f;                        // movement speed of player
final float LOWER_X_BOUND = -1+PLAYER_SIZE;           // lower x constraint for player location
final float UPPER_X_BOUND = 1-PLAYER_SIZE;            // upper x constraint for player location
final float LOWER_Y_BOUND = -1+PLAYER_SIZE;           // lower y constraint for player location
final float UPPER_Y_BOUND = 1-PLAYER_SIZE;            // upper y constraint for player location
final float HOME_X = 0;                               // x coord. of "home"
final float HOME_Y = -0.8f;                            // y coord. of "home"
final float HOME_ERROR = 0.005f;                       // margin of error in "home" location to prevent jittering
final float DRIFT_SPEED  = MOVE_SPEED/5;              // speed player drifts back to "home" at
final float PLAYER_BULLET_SPEED = 0.05f;               // speed of player's bullets
final float ROTATION_ANGLE = PI/7;                    // angle by which player rotates while moving
final float PLAYER_BULLET_SIZE = PLAYER_SIZE/3;       // size of player's bullets
final PVector BULLET_DIRECTION = new PVector(0, 1);   // direction player shoots in (straight up)
final float[] PLAYER_COLOUR = {1, 1, 1};              // colour of player's square
final int SHOOT_SPACING = 5;                          // number of frames that must pass before player can shoot again
int framesSinceShot = SHOOT_SPACING;                  // number of frames since player has shot

float xPlayer = 0;                        // x coord. of player
float yPlayer = -0.7f;                     // y coord. of player
boolean moveLeft = false;                 // boolean to track if player is moving left
boolean moveRight = false;                // boolean to track if player is moving right
boolean moveUp = false;                   // boolean to track if player is moving up
boolean moveDown = false;                 // boolean to track if player is moving down
boolean playerShooting = false;           // boolean to track if player is shootin
Bullets playerBullets = new Bullets();    // bullets shot by player

/*
  This method makes the player shoot a bullet.
 */
 public void playerShoots() {
  // Shoot if not recently shot
  if (framesSinceShot == SHOOT_SPACING) {
    // Reset tracker
    framesSinceShot = 0;

    // Add new bullet at player's location
    playerBullets.add(xPlayer, yPlayer, BULLET_DIRECTION, PLAYER_BULLET_SPEED, Textures.playerBullet, PLAYER_BULLET_SIZE);
  } else
    framesSinceShot++;
}// playerShoots

/*
  This method draws the player at its current location.
 */
 public void drawPlayer() {
  // Check if player should be rotated or not
  float rotationX = (moveRight || moveLeft) ? ROTATION_ANGLE : 0;
  float rotationY = (moveUp || moveDown) ? ROTATION_ANGLE : 0;

  // Flip sign based on direction
  if (moveLeft)
    rotationX = -rotationX;
  if (moveUp)
    rotationY = - rotationY;

  // Draw player
  pushMatrix();
  // Color player
  fill(PLAYER_COLOUR[RED], PLAYER_COLOUR[GREEN], PLAYER_COLOUR[BLUE]);
  // Apply transformations
  translate(xPlayer, yPlayer, PLAYER_HEIGHT);
  rotateY(rotationX);
  rotateX(rotationY);
  scale(PLAYER_SIZE, PLAYER_SIZE, 1);

  // Draw sqaure coloured or textured square
  if (doTextures)
    drawSquare(null, Textures.player);
  else
    drawSquare(PLAYER_COLOUR, null);

  popMatrix();
}// drawPlayer

/*
  This method updates the flags for player movement and drifts home if needed.
 */
 public void updatePlayer() {
  // Check for flags
  if (moveLeft)
    movePlayerLeft(MOVE_SPEED);
  if (moveRight)
    movePlayerRight(MOVE_SPEED);
  if (moveUp)
    movePlayerUp(MOVE_SPEED);
  if (moveDown)
    movePlayerDown(MOVE_SPEED);
  if (playerShooting)
    playerShoots();

  // Check if no user input
  if (!moveLeft && !moveRight && !moveUp && !moveDown)
    // Drift player home
    driftHome();
}// movePlayer

/*
  This method moves the player towards its "home" location at a set speed.
 */
 public void driftHome() {
  // Proceed based on current x position
  if ((xPlayer - HOME_X) > HOME_ERROR)
    // Move left
    movePlayerLeft(DRIFT_SPEED);
  else if ((HOME_X - xPlayer) > HOME_ERROR)
    // Move right
    movePlayerRight(DRIFT_SPEED);

  // Proceed based on current y position
  if ((yPlayer - HOME_Y) > HOME_ERROR)
    // Move down
    movePlayerDown(DRIFT_SPEED);
  else if ((HOME_Y - yPlayer) > HOME_ERROR)
    // Move up
    movePlayerUp(DRIFT_SPEED);
}// driftHome

/*
  This method moves the player left at a given speed, while keeping it within bounds.
 */
 public void movePlayerLeft(float speed) {
  xPlayer = constrain(xPlayer-speed, LOWER_X_BOUND, UPPER_X_BOUND);
}// movePlayerLeft

/*
  This method moves the player right at a given speed, while keeping it within bounds.
 */
 public void movePlayerRight(float speed) {
  xPlayer = constrain(xPlayer+speed, LOWER_X_BOUND, UPPER_X_BOUND);
}// movePlayerLeft

/*
  This method moves the player up at a given speed, while keeping it within bounds.
 */
 public void movePlayerUp(float speed) {
  yPlayer = constrain(yPlayer+speed, LOWER_Y_BOUND, UPPER_Y_BOUND);
}// movePlayerLeft

/*
  This method moves the player down at a given speed, while keeping it within bounds.
 */
 public void movePlayerDown(float speed) {
  yPlayer = constrain(yPlayer-speed, LOWER_Y_BOUND, UPPER_Y_BOUND);
}// movePlayerLeft
// Functions to compel Processing to let us edit the projection matrix

PGraphicsOpenGL pogl = null;

// called at the beginning of your code
 public void setupPOGL() {
  pogl = (PGraphicsOpenGL)g;
}

// for debugging
 public void printProjection() {
  pogl.projection.print();
}

// call immediately after using perspective() to create a view frustum
 public void fixFrustumYAxis() {
  PMatrix3D projection = getProjection();
  projection.preApply(new PMatrix3D(
    1, 0, 0, 0,
    0, -1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
    ));
  setProjection(projection);
}

 public PMatrix3D getProjection() {
  assert pogl != null: "no PGraphics OpenGL context";
  return pogl.projection.get();
}

 public void setProjection(PMatrix3D projectionMatrix) {
  assert pogl != null: "no PGraphics OpenGL context";
  pogl.projection.set(projectionMatrix.get());
  pogl.updateProjmodelview();
}
/*
Put your projection and camera operations here.
Add more constants, variables and functions as needed.
*/

PMatrix3D projectOrtho, projectPerspective;

 public void setupProjections() {
  ortho(L, R, T, B);
  projectOrtho = getProjection();
  
  frustum(L, R, B, T, N, F);

  fixFrustumYAxis();
  projectPerspective = getProjection();
  
  setProjection(projectOrtho);
}
final float PLAYER_RADIUS = PLAYER_SIZE*3/4;              // radius of player's hitbox
final float ENEMY_RADIUS = ENEMY_SIZE/3;                  // radius of enemy's hitbox
final float ENEMY_BULLET_RADIUS = ENEMY_BULLET_SIZE/2;    // radius of enemy's bullet hitbox
final float PLAYER_BULLET_RADIUS = PLAYER_BULLET_SIZE/2;  // radius of player's bullet hitbox

/*
  All textures that are used to create the game.
 */
enum Textures {
  enemy1,
    enemy2,
    enemy3,
    player,
    playerBullet,
    enemyBullet,
    tile1,
    tile2
}// Textures

/*
  This method checks collision between player, enemies, and bullets.
 */
 public void checkCollisions() {
  playerCollide();
  enemyCollide();
  bulletsCollide();
}// checkCollision

/*
  This method checks if a player collided with an enemy or their bullets.
 */
 public void playerCollide() {
  Enemy e;    // current enemy

  // Check if the player collides with any enemies or their bulletss
  for (int i=0; i<enemies.size(); i++) {
    // Get current enemt
    e = enemies.get(i);

    // Check if enemy collided with player
    playerEnemyCollision(e);

    // Check if the player collides with any bullets from this enemy
    for (int j=0; j<e.enemyBullets.bullets.size(); j++) {
      // Check if bullet collides with player
      playerBulletCollision(e, e.enemyBullets.bullets.get(j));
    }// for
  }// for
}// playerCollide

/*
  This method checks if an enemy collided with any player bullets.
 */
 public void enemyCollide() {
  Enemy e;    // current enemy

  // Check each enemy
  for (int i=0; i<enemies.size(); i++) {
    // Get current enemy
    e = enemies.get(i);

    // Check if the enemy collides with any player bullets
    for (int j=0; j<playerBullets.bullets.size(); j++) {
      enemyBulletCollision(e, playerBullets.bullets.get(j));
    }// for
  }// for
}// enemyCollide

/*
  This method checks if an enemy bullet and a player bullet collided.
 */
 public void bulletsCollide() {
  Enemy e;                    // current enemy
  boolean removed = false;    // boolean to track if a bullet has been removed

  // Check each enemy
  for (int i=0; i<enemies.size(); i++) {
    // Get current enemy
    e = enemies.get(i);

    // Check all bullets
    for (int k=0; k<e.enemyBullets.bullets.size(); k++) {
      removed = false;

      // Check if the enemy bullets collides with any player bullets
      for (int j=0; j<playerBullets.bullets.size() && !removed; j++) {
        removed = twoBulletCollision(e, e.enemyBullets.bullets.get(k), playerBullets.bullets.get(j));
      }// for
    }// for
  }// for
}// bulletCollide

/*
  This method checks if two bullets collided and destroys them if they did.
 */
 public Boolean twoBulletCollision(Enemy e, Bullet enemyBullet, Bullet playerBullet) {
  PVector enemyBulletLocation = new PVector(enemyBullet.xPos, enemyBullet.yPos);
  PVector playerBulletLocation = new PVector(playerBullet.xPos, playerBullet.yPos);
  float radiiSum = PLAYER_BULLET_RADIUS+ENEMY_BULLET_RADIUS;
  float dist;
  Boolean collision = false;

  // Get distance between locations
  dist = PVector.dist(enemyBulletLocation, playerBulletLocation);

  // Check for collision
  if (dist <= radiiSum) {
    collision = true;

    // Destroy enemy and player bullets
    destroyBullet(e, enemyBullet);
    destroyBullet(null, playerBullet);
  }// if

  return collision;
}// twoBulletCollision

/*
  This method checks if a player and enemy collided and destroys them if they did.
 */
 public void playerEnemyCollision(Enemy e) {
  PVector enemyLocation = new PVector(e.xPos, e.yPos);
  PVector playerLocation = new PVector(xPlayer, yPlayer);
  float radiiSum = PLAYER_RADIUS + ENEMY_RADIUS;
  float dist;

  // Get distance between locations
  dist = PVector.dist(enemyLocation, playerLocation);

  // Check for collision
  if (dist <= radiiSum) {
    // Destroy enemy and player
    destroyEnemy(e);
    destroyPlayer();
  }// if
}// playerEnemyCollision

/*
  This method checks if a player and enemy bullet collided and destroys them if they did.
 */
 public void playerBulletCollision(Enemy e, Bullet b) {
  PVector bulletLocation = new PVector(b.xPos, b.yPos);
  PVector playerLocation = new PVector(xPlayer, yPlayer);
  float radiiSum = PLAYER_RADIUS + ENEMY_BULLET_RADIUS;
  float dist;

  // Get distance between locations
  dist = PVector.dist(bulletLocation, playerLocation);

  // Check for collision
  if (dist <= radiiSum) {
    // Destroy enemy and player
    destroyBullet(e, b);
    destroyPlayer();
  }// if
}// playerBulletCollision

/*
  This method checks if an enemy and player bullet collided and destroys them if they did.
 */
 public void enemyBulletCollision(Enemy e, Bullet b) {
  // Proceed if enemy is alive
  if (e.alive) {
    PVector bulletLocation = new PVector(b.xPos, b.yPos);
    PVector enemyLocation = new PVector(e.xPos, e.yPos);
    float radiiSum = ENEMY_RADIUS + PLAYER_BULLET_RADIUS;
    float dist;

    // Get distance between locations
    dist = PVector.dist(bulletLocation, enemyLocation);

    // Check for collision
    if (dist <= radiiSum) {
      // Destroy enemy and player
      destroyBullet(null, b);
      destroyEnemy(e);
    }// if
  }// if
}// enemyBulletCollision

/*
  This method destroys a given enemy and adds an explosion at that location.
 */
 public void destroyEnemy(Enemy e) {
  e.alive = false;

  // Create an explosion at enemy location
  explosions.add(new Explosion(e.xPos, e.yPos));
}// destroyEnemy

/*
  This method destroys a given bullet.
 */
 public void destroyBullet(Enemy e, Bullet b) {
  if (e != null)
    e.enemyBullets.bullets.remove(b);
  else
    playerBullets.bullets.remove(b);
}// destroyEnemy

/*
  This method destroys the player, adds an explosion at that location, and ends the game.
 */
 public void destroyPlayer() {
  // Create an explosion at enemy location
  explosions.add(new Explosion(xPlayer, yPlayer));
  endGame();
}// destroyPlayer

/*
  This method ends the game and stops any player movement/shootin.
 */
 public void endGame() {
  gameOver = true;
  moveLeft = false;
  moveRight = false;
  moveUp = false;
  moveDown = false;
  playerShooting = false;
}// endGame

/*
  This method runs all the current explosions and removes any dead explosions.
 */
 public void runExplosions() {
  Explosion e;    // current explosion

  // Loop through all explosions
  for (int i=0; i<explosions.size(); i++) {
    e = explosions.get(i);

    // Run each explosion
    e.run();

    // Check if explosion should be removed
    if (!e.alive)
      explosions.remove(e);
  }// for
}// runExplosions

/*
  This method sets up all the images used for textures.
 */
 public void setupImages() {
  PLAYER_IMAGE = loadImage(PLAYER_FILE_NAME);
  ENEMY_IMAGE1 = loadImage(ENEMY_FILE1_NAME);
  ENEMY_IMAGE2 = loadImage(ENEMY_FILE2_NAME);
  ENEMY_IMAGE3 = loadImage(ENEMY_FILE3_NAME);
  PLAYER_BULLET_IMAGE = loadImage(PLAYER_BULLET_FILE_NAME);
  ENEMY_BULLET_IMAGE = loadImage(ENEMY_BULLET_FILE_NAME);
  SIDE_TILE_IMAGE = loadImage(SIDE_TILE_NAME);
  TOP_TILE_IMAGE1 = loadImage(TOP_TILE_NAME1);
  TOP_TILE_IMAGE2 = loadImage(TOP_TILE_NAME2);
}// setupImages


/*
  This method draws a cube in model space.
 */
 public void drawCube(float[] cubeColor, Textures t) {
  // Proceed based on type of cube
  if (!doTextures)
    drawColouredCube(cubeColor);
  else
    drawTexturedCube(t);
}// drawCube

/*
  This method draws a cube for a particle in model space.
 */
 public void drawParticleCube(float[] cubeColor) {
  drawColouredCube(cubeColor);
}// drawCube

/*
  This method draws a textured cube in model space, given the texture.
 */
 public void drawTexturedCube(Textures t) {
  // Draw front face
  beginShape(QUADS);
  if (t == Textures.tile1 || t == Textures.tile2)
    texture(SIDE_TILE_IMAGE);
  vertex(-1, -1, -1, 0, 0);
  vertex(1, -1, -1, 1, 0);
  vertex(1, -1, 1, 1, 1);
  vertex(-1, -1, 1, 0, 1);

  // Draw back face
  vertex(-1, 1, -1, 0, 0);
  vertex(1, 1, -1, 1, 0);
  vertex(1, 1, 1, 1, 1);
  vertex(-1, 1, 1, 0, 1);

  // Draw left face
  vertex(-1, 1, -1, 1, 0);
  vertex(-1, -1, -1, 0, 0);
  vertex(-1, -1, 1, 0, 1);
  vertex(-1, 1, 1, 1, 1);

  // Draw right face
  vertex(1, 1, -1, 1, 0);
  vertex(1, -1, -1, 0, 0);
  vertex(1, -1, 1, 0, 1);
  vertex(1, 1, 1, 1, 1);

  // Draw bottom face
  vertex(-1, -1, -1, 0, 0);
  vertex(1, -1, -1, 1, 0);
  vertex(1, 1, -1, 1, 1);
  vertex(-1, 1, -1, 0, 1);
  endShape();

  // Draw top face
  beginShape(QUAD);
  if (t == Textures.tile1)
    texture(TOP_TILE_IMAGE1);
  else if (t == Textures.tile2)
    texture(TOP_TILE_IMAGE2);
  vertex(-1, -1, 1, 0, 0);
  vertex(1, -1, 1, 1, 0);
  vertex(1, 1, 1, 1, 1);
  vertex(-1, 1, 1, 0, 1);
  endShape();
}// drawTexturedCube

/*
  This method draws a coloured cube in model space, given the colour.
 */
 public void drawColouredCube(float[] colour) {
  fill(colour[RED], colour[GREEN], colour[BLUE]);
  noStroke();

  beginShape(QUADS);
  // Draw front face
  vertex(-1, -1, -1);
  vertex(1, -1, -1);
  vertex(1, -1, 1);
  vertex(-1, -1, 1);

  // Draw back face;
  vertex(-1, 1, -1);
  vertex(1, 1, -1);
  vertex(1, 1, 1);
  vertex(-1, 1, 1);

  // Draw left face
  vertex(-1, 1, -1);
  vertex(-1, -1, -1);
  vertex(-1, -1, 1);
  vertex(-1, 1, 1);

  // Draw right face
  vertex(1, 1, -1);
  vertex(1, -1, -1);
  vertex(1, -1, 1);
  vertex(1, 1, 1);

  // Draw bottom face
  vertex(-1, -1, -1);
  vertex(1, -1, -1);
  vertex(1, 1, -1);
  vertex(-1, 1, -1);

  // Draw top face
  vertex(-1, -1, 1);
  vertex(1, -1, 1);
  vertex(1, 1, 1);
  vertex(-1, 1, 1);
  endShape();
}// drawColouredCube

/*
  This method draws a textured or coloured cube in model space, given the texture/colour.
 */
 public void drawSquare(float[] colour, Textures t) {
  // Check if textured
  if (t == null)
    drawColouredSquare(colour);
  else
    drawTexturedSquare(t);
}// drawSquare

/*
  This method draws a coloured square in model space, given the colour.
 */
 public void drawColouredSquare(float[] colour) {
  fill(colour[RED], colour[GREEN], colour[BLUE]);

  beginShape(QUAD);

  // Draw square
  vertex(-1, -1, 0, 1);
  vertex(1, -1, 1, 1);
  vertex(1, 1, 1, 0);
  vertex(-1, 1, 0, 0);

  endShape();
}// drawColouredSquare

/*
  This method draws a textured square in model space, given the texture.
 */
 public void drawTexturedSquare(Textures t) {
  beginShape(QUAD);

  // Choose correct shading
  if (t == Textures.player)
    texture(PLAYER_IMAGE);
  else if (t == Textures.enemy1)
    texture(ENEMY_IMAGE1);
  else if (t == Textures.enemy2)
    texture(ENEMY_IMAGE2);
  else if (t == Textures.enemy3)
    texture(ENEMY_IMAGE3);
  else if (t == Textures.enemyBullet)
    texture(ENEMY_BULLET_IMAGE);
  else if (t == Textures.playerBullet)
    texture(PLAYER_BULLET_IMAGE);
  
  // Draw sqaure
  vertex(-1, -1, 0, 1);
  vertex(1, -1, 1, 1);
  vertex(1, 1, 1, 0);
  vertex(-1, 1, 0, 0);

  endShape();
}// drawColouredSquare


  public void settings() { size(640, 640, P3D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "BrarTajA3" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
